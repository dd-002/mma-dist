function e(e,t,r,n){Object.defineProperty(e,t,{get:r,set:n,enumerable:!0,configurable:!0})}var t,r="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},o={},i=r.parcelRequire69cf;null==i&&((i=function(e){if(e in n)return n[e].exports;if(e in o){var t=o[e];delete o[e];var r={id:e,exports:{}};return n[e]=r,t.call(r.exports,r,r.exports),r.exports}var i=Error("Cannot find module '"+e+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(e,t){o[e]=t},r.parcelRequire69cf=i),i.register("aV8T4",function(t,r){e(t.exports,"ScrollTrigger",function(){return tg});/*!
 * ScrollTrigger 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*//* eslint-disable */var n,o,a,s,l,c,u,f,p,d,g,h,v,m,y,b,_,x,w,T,S,M,E,P,A,C,k,O,z,q,R,N,D,Y,X,F,I=i("2lFfT"),L=1,B=Date.now,H=B(),W=0,V=0,U=function(e,t,r){var n=ea(e)&&("clamp("===e.substr(0,6)||e.indexOf("max")>-1);return r["_"+t+"Clamp"]=n,n?e.substr(6,e.length-7):e},G=function(e,t){return t&&(!ea(e)||"clamp("!==e.substr(0,6))?"clamp("+e+")":e},j=function(){return m=1},Z=function(){return m=0},$=function(e){return e},K=function(e){return Math.round(1e5*e)/1e5||0},J=function(){return"undefined"!=typeof window},Q=function(){return n||J()&&(n=window.gsap)&&n.registerPlugin&&n},ee=function(e){return!!~u.indexOf(e)},et=function(e){return("Height"===e?R:a["inner"+e])||l["client"+e]||c["client"+e]},er=function(e){return(0,I._getProxyProp)(e,"getBoundingClientRect")||(ee(e)?function(){return ts.width=a.innerWidth,ts.height=R,ts}:function(){return eA(e)})},en=function(e,t,r){var n=r.d,o=r.d2,i=r.a;return(i=(0,I._getProxyProp)(e,"getBoundingClientRect"))?function(){return i()[n]}:function(){return(t?et(o):e["client"+o])||0}},eo=function(e,t){var r=t.s,n=t.d2,o=t.d,i=t.a;return Math.max(0,(r="scroll"+n,i=(0,I._getProxyProp)(e,r))?i()-er(e)()[o]:ee(e)?(l[r]||c[r])-et(n):e[r]-e["offset"+n])},ei=function(e,t){for(var r=0;r<w.length;r+=3)(!t||~t.indexOf(w[r+1]))&&e(w[r],w[r+1],w[r+2])},ea=function(e){return"string"==typeof e},es=function(e){return"function"==typeof e},el=function(e){return"number"==typeof e},ec=function(e){return"object"==typeof e},eu=function(e,t,r){return e&&e.progress(t?0:1)&&r&&e.pause()},ef=function(e,t){if(e.enabled){var r=t(e);r&&r.totalTime&&(e.callbackAnimation=r)}},ep=Math.abs,ed="left",eg="right",eh="bottom",ev="width",em="height",ey="Right",eb="Left",e_="Bottom",ex="padding",ew="margin",eT="Width",eS="Height",eM=function(e){return a.getComputedStyle(e)},eE=function(e){// if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
var t=eM(e).position;e.style.position="absolute"===t||"fixed"===t?t:"relative"},eP=function(e,t){for(var r in t)r in e||(e[r]=t[r]);return e},eA=function(e,t){var r=t&&"matrix(1, 0, 0, 1, 0, 0)"!==eM(e)[y]&&n.to(e,{x:0,y:0,xPercent:0,yPercent:0,rotation:0,rotationX:0,rotationY:0,scale:1,skewX:0,skewY:0}).progress(1),o=e.getBoundingClientRect();return r&&r.progress(0).kill(),o},eC=function(e,t){var r=t.d2;return e["offset"+r]||e["client"+r]||0},ek=function(e){var t,r=[],n=e.labels,o=e.duration();for(t in n)r.push(n[t]/o);return r},eO=function(e){var t=n.utils.snap(e),r=Array.isArray(e)&&e.slice(0).sort(function(e,t){return e-t});return r?function(e,n,o){var i;if(void 0===o&&(o=.001),!n)return t(e);if(n>0){for(e-=o,i=0;i<r.length;i++)if(r[i]>=e)return r[i];return r[i-1]}for(i=r.length,e+=o;i--;)if(r[i]<=e)return r[i];return r[0]}:function(r,n,o){void 0===o&&(o=.001);var i=t(r);return!n||Math.abs(i-r)<o||i-r<0==n<0?i:t(n<0?r-e:r+e)}},ez=function(e,t,r,n){return r.split(",").forEach(function(r){return e(t,r,n)})},eq=function(e,t,r,n,o){return e.addEventListener(t,r,{passive:!n,capture:!!o})},eR=function(e,t,r,n){return e.removeEventListener(t,r,!!n)},eN=function(e,t,r){(r=r&&r.wheelHandler)&&(e(t,"wheel",r),e(t,"touchmove",r))},eD={startColor:"green",endColor:"red",indent:0,fontSize:"16px",fontWeight:"normal"},eY={toggleActions:"play",anticipatePin:0},eX={top:0,left:0,center:.5,bottom:1,right:1},eF=function(e,t){if(ea(e)){var r=e.indexOf("="),n=~r?+(e.charAt(r-1)+1)*parseFloat(e.substr(r+1)):0;~r&&(e.indexOf("%")>r&&(n*=t/100),e=e.substr(0,r-1)),e=n+(e in eX?eX[e]*t:~e.indexOf("%")?parseFloat(e)*t/100:parseFloat(e)||0)}return e},eI=function(e,t,r,n,o,i,a,l){var u=o.startColor,f=o.endColor,p=o.fontSize,d=o.indent,g=o.fontWeight,h=s.createElement("div"),v=ee(r)||"fixed"===(0,I._getProxyProp)(r,"pinType"),m=-1!==e.indexOf("scroller"),y=v?c:r,b=-1!==e.indexOf("start"),_=b?u:f,x="border-color:"+_+";font-size:"+p+";color:"+_+";font-weight:"+g+";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";return x+="position:"+((m||l)&&v?"fixed;":"absolute;"),(m||l||!v)&&(x+=(n===I._vertical?eg:eh)+":"+(i+parseFloat(d))+"px;"),a&&(x+="box-sizing:border-box;text-align:left;width:"+a.offsetWidth+"px;"),h._isStart=b,h.setAttribute("class","gsap-marker-"+e+(t?" marker-"+t:"")),h.style.cssText=x,h.innerText=t||0===t?e+"-"+t:e,y.children[0]?y.insertBefore(h,y.children[0]):y.appendChild(h),h._offset=h["offset"+n.op.d2],eL(h,0,n,b),h},eL=function(e,t,r,o){var i={display:"block"},a=r[o?"os2":"p2"],s=r[o?"p2":"os2"];e._isFlipped=o,i[r.a+"Percent"]=o?-100:0,i[r.a]=o?"1px":0,i["border"+a+eT]=1,i["border"+s+eT]=0,i[r.p]=t+"px",n.set(e,i)},eB=[],eH={},eW=function(){return B()-W>34&&(D||(D=requestAnimationFrame(e9)))},eV=function(){// previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
E&&E.isPressed&&!(E.startX>c.clientWidth)||(I._scrollers.cache++,E?D||(D=requestAnimationFrame(e9)):e9(),W||eK("scrollStart"),W=B())},eU=function(){C=a.innerWidth,A=a.innerHeight},eG=function(){I._scrollers.cache++,!(!v&&!M&&!s.fullscreenElement&&!s.webkitFullscreenElement&&(!P||C!==a.innerWidth||Math.abs(a.innerHeight-A)>.25*a.innerHeight))||f.restart(!0)},ej={},eZ=[],e$=function e(){return eR(tg,"scrollEnd",e)||e4(!0)},eK=function(e){return ej[e]&&ej[e].map(function(e){return e()})||eZ},eJ=[],eQ=function(e){for(var t=0;t<eJ.length;t+=5)(!e||eJ[t+4]&&eJ[t+4].query===e)&&(eJ[t].style.cssText=eJ[t+1],eJ[t].getBBox&&eJ[t].setAttribute("transform",eJ[t+2]||""),eJ[t+3].uncache=1)},e0=function(e,t){var r;for(b=0;b<eB.length;b++)(r=eB[b])&&(!t||r._ctx===t)&&(e?r.kill(1):r.revert(!0,!0));t&&eQ(t),t||eK("revert")},e1=function(e,t){I._scrollers.cache++,(t||!Y)&&(0,I._scrollers).forEach(function(e){return es(e)&&e.cacheID++&&(e.rec=0)}),ea(e)&&(a.history.scrollRestoration=z=e)},e2=0,e5=function(){// we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's "load" or "DOMContentLoaded" events to trigger it.
if(X!==e2){var e=X=e2;requestAnimationFrame(function(){return e===e2&&e4(!0)})}},e3=function(){c.appendChild(q),R=q.offsetHeight||a.innerHeight,c.removeChild(q)},e4=function(e,t){if(W&&!e){eq(tg,"scrollEnd",e$);return}e3(),Y=tg.isRefreshing=!0,(0,I._scrollers).forEach(function(e){return es(e)&&++e.cacheID&&(e.rec=e())});var r=eK("refreshInit");T&&tg.sort(),t||e0(),(0,I._scrollers).forEach(function(e){es(e)&&(e.smooth&&(e.target.style.scrollBehavior="auto"),e(0))}),eB.slice(0).forEach(function(e){return e.refresh()}),eB.forEach(function(e,t){// nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.
if(e._subPinOffset&&e.pin){var r=e.vars.horizontal?"offsetWidth":"offsetHeight",n=e.pin[r];e.revert(!0,1),e.adjustPinSpacing(e.pin[r]-n),e.refresh()}}),eB.forEach(function(e){// the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max". Same for anything with a clamped end
var t=eo(e.scroller,e._dir);("max"===e.vars.end||e._endClamp&&e.end>t)&&e.setPositions(e.start,Math.max(e.start+1,t),!0)}),r.forEach(function(e){return e&&e.render&&e.render(-1)}),(0,I._scrollers).forEach(function(e){es(e)&&(e.smooth&&requestAnimationFrame(function(){return e.target.style.scrollBehavior="smooth"}),e.rec&&e(e.rec))}),e1(z,1),f.pause(),e2++,Y=2,e9(2),eB.forEach(function(e){return es(e.vars.onRefresh)&&e.vars.onRefresh(e)}),Y=tg.isRefreshing=!1,eK("refresh")},e6=0,e8=1,e9=function(e){if(!Y||2===e){tg.isUpdating=!0,F&&F.update(0);var t=eB.length,r=B(),n=r-H>=50,o=t&&eB[0].scroll();if(e8=e6>o?-1:1,Y||(e6=o),n&&(W&&!m&&r-W>200&&(W=0,eK("scrollEnd")),g=H,H=r),e8<0){for(b=t;b-- >0;)eB[b]&&eB[b].update(0,n);e8=1}else for(b=0;b<t;b++)eB[b]&&eB[b].update(0,n);tg.isUpdating=!1}D=0},e7=[ed,"top",eh,eg,ew+e_,ew+ey,ew+"Top",ew+eb,"display","flexShrink","float","zIndex","gridColumnStart","gridColumnEnd","gridRowStart","gridRowEnd","gridArea","justifySelf","alignSelf","placeSelf","order"],te=e7.concat([ev,em,"boxSizing","max"+eT,"max"+eS,"position",ew,ex,ex+"Top",ex+ey,ex+e_,ex+eb]),tt=function(e,t,r){to(r);var n=e._gsap;if(n.spacerIsNative)to(n.spacerState);else if(e._gsap.swappedIn){var o=t.parentNode;o&&(o.insertBefore(e,t),o.removeChild(t))}e._gsap.swappedIn=!1},tr=function(e,t,r,n){if(!e._gsap.swappedIn){for(var o,i=e7.length,a=t.style,s=e.style;i--;)a[o=e7[i]]=r[o];a.position="absolute"===r.position?"absolute":"relative","inline"===r.display&&(a.display="inline-block"),s[eh]=s[eg]="auto",a.flexBasis=r.flexBasis||"auto",a.overflow="visible",a.boxSizing="border-box",a[ev]=eC(e,I._horizontal)+"px",a[em]=eC(e,I._vertical)+"px",a[ex]=s[ew]=s.top=s[ed]="0",to(n),s[ev]=s["max"+eT]=r[ev],s[em]=s["max"+eS]=r[em],s[ex]=r[ex],e.parentNode!==t&&(e.parentNode.insertBefore(t,e),t.appendChild(e)),e._gsap.swappedIn=!0}},tn=/([A-Z])/g,to=function(e){if(e){var t,r,o=e.t.style,i=e.length,a=0;for((e.t._gsap||n.core.getCache(e.t)).uncache=1;a<i;a+=2)r=e[a+1],t=e[a],r?o[t]=r:o[t]&&o.removeProperty(t.replace(tn,"-$1").toLowerCase())}},ti=function(e){for(// returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
var t=te.length,r=e.style,n=[],o=0;o<t;o++)n.push(te[o],r[te[o]]);return n.t=e,n},ta=function(e,t,r){for(var n,o=[],i=e.length,a=r?8:0;a<i;a+=2)n=e[a],o.push(n,n in t?t[n]:e[a+1]);return o.t=e.t,o},ts={left:0,top:0},// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
// 	scroller = _getTarget(scroller || _win);
// 	let direction = horizontal ? _horizontal : _vertical,
// 		isViewport = _isViewport(scroller);
// 	_getSizeFunc(scroller, isViewport, direction);
// 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
// },
tl=function(e,t,r,o,i,a,s,u,f,p,d,g,h,v){es(e)&&(e=e(u)),ea(e)&&"max"===e.substr(0,3)&&(e=g+("="===e.charAt(4)?eF("0"+e.substr(3),r):0));var m,y,b,_=h?h.time():0;if(h&&h.seek(0),isNaN(e)||(e=+e),el(e))h&&(e=n.utils.mapRange(h.scrollTrigger.start,h.scrollTrigger.end,0,g,e)),s&&eL(s,r,o,!0);else{es(t)&&(t=t(u));var x,w,T,S,M=(e||"0").split(" ");(x=eA(b=(0,I._getTarget)(t,u)||c)||{}).left||x.top||"none"!==eM(b).display||(// if display is "none", it won't report getBoundingClientRect() properly
S=b.style.display,b.style.display="block",x=eA(b),S?b.style.display=S:b.style.removeProperty("display")),w=eF(M[0],x[o.d]),T=eF(M[1]||"0",r),e=x[o.p]-f[o.p]-p+w+i-T,s&&eL(s,T,o,r-T<20||s._isStart&&T>20),r-=r-T}if(v&&(u[v]=e||-.001,e<0&&(e=0)),a){var E=e+r,P=a._isStart;m="scroll"+o.d2,eL(a,E,o,P&&E>20||!P&&(d?Math.max(c[m],l[m]):a.parentNode[m])<=E+1),d&&(f=eA(s),d&&(a.style[o.op.p]=f[o.op.p]-o.op.m-a._offset+"px"))}return h&&b&&(m=eA(b),h.seek(g),y=eA(b),h._caScrollDist=m[o.p]-y[o.p],e=e/h._caScrollDist*g),h&&h.seek(_),h?e:Math.round(e)},tc=/(webkit|moz|length|cssText|inset)/i,tu=function(e,t,r,o){if(e.parentNode!==t){var i,a,s=e.style;if(t===c){for(i in e._stOrig=s.cssText,a=eM(e))+i||tc.test(i)||!a[i]||"string"!=typeof s[i]||"0"===i||(s[i]=a[i]);s.top=r,s.left=o}else s.cssText=e._stOrig;n.core.getCache(e).uncache=1,t.appendChild(e)}},tf=function(e,t,r){var n=t,o=n;return function(t){var i=Math.round(e());// round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.
return i!==n&&i!==o&&Math.abs(i-n)>3&&Math.abs(i-o)>3&&(// if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
t=i,r&&r()),o=n,n=t,t}},tp=function(e,t,r){var o={};o[t.p]="+="+r,n.set(e,o)},// 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
// 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
// 	tl.smoothChildTiming = false;
// 	return tl;
// },
// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
td=function(e,t){var r=(0,I._getScrollFunc)(e,t),o="_scroll"+t.p2,i=function t(i,a,s,l,c){var u=t.tween,f=a.onComplete,p={};s=s||r();var d=tf(r,s,function(){u.kill(),t.tween=0});return c=l&&c||0,l=l||i-s,u&&u.kill(),a[o]=i,a.modifiers=p,p[o]=function(){return d(s+l*u.ratio+c*u.ratio*u.ratio)},a.onUpdate=function(){I._scrollers.cache++,e9()},a.onComplete=function(){t.tween=0,f&&f.call(u)},u=t.tween=n.to(e,a)};return e[o]=r,r.wheelHandler=function(){return i.tween&&i.tween.kill()&&(i.tween=0)},eq(e,"wheel",r.wheelHandler),tg.isTouch&&eq(e,"touchmove",r.wheelHandler),i},tg=/*#__PURE__*/function(){function e(t,r){o||e.register(n)||console.warn("Please gsap.registerPlugin(ScrollTrigger)"),O(this),this.init(t,r)}return e.prototype.init=function(t,r){if(this.progress=this.start=0,this.vars&&this.kill(!0,!0),!V){this.update=this.refresh=this.kill=$;return}var o,i,u,f,h,y,_,x,w,M,E,P,A,C,k,O,z,q,R,D,X,H,j,Z,J,Q,et,ei,ed,eg,eh,ez,eN,eX,eL,eW,eU,ej,eZ,eK,eJ,eQ=t=eP(ea(t)||el(t)||t.nodeType?{trigger:t}:t,eY),e0=eQ.onUpdate,e1=eQ.toggleClass,e2=eQ.id,e3=eQ.onToggle,e4=eQ.onRefresh,e6=eQ.scrub,e9=eQ.trigger,e7=eQ.pin,te=eQ.pinSpacing,tn=eQ.invalidateOnRefresh,tc=eQ.anticipatePin,tf=eQ.onScrubComplete,tg=eQ.onSnapComplete,th=eQ.once,tv=eQ.snap,tm=eQ.pinReparent,ty=eQ.pinSpacer,tb=eQ.containerAnimation,t_=eQ.fastScrollEnd,tx=eQ.preventOverlaps,tw=t.horizontal||t.containerAnimation&&!1!==t.horizontal?I._horizontal:I._vertical,tT=!e6&&0!==e6,tS=(0,I._getTarget)(t.scroller||a),tM=n.core.getCache(tS),tE=ee(tS),tP=("pinType"in t?t.pinType:(0,I._getProxyProp)(tS,"pinType")||tE&&"fixed")==="fixed",tA=[t.onEnter,t.onLeave,t.onEnterBack,t.onLeaveBack],tC=tT&&t.toggleActions.split(" "),tk="markers"in t?t.markers:eY.markers,tO=tE?0:parseFloat(eM(tS)["border"+tw.p2+eT])||0,tz=this,tq=t.onRefreshInit&&function(){return t.onRefreshInit(tz)},tR=en(tS,tE,tw),tN=!tE||~(0,I._proxies).indexOf(tS)?er(tS):function(){return ts},tD=0,tY=0,tX=0,tF=(0,I._getScrollFunc)(tS,tw);// for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start="clamp(top bottom)" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.
if(tz._startClamp=tz._endClamp=!1,tz._dir=tw,tc*=45,tz.scroller=tS,tz.scroll=tb?tb.time.bind(tb):tF,y=tF(),tz.vars=t,r=r||t.animation,"refreshPriority"in t&&(T=1,-9999===t.refreshPriority&&(F=tz)),tM.tweenScroll=tM.tweenScroll||{top:td(tS,I._vertical),left:td(tS,I._horizontal)},tz.tweenTo=u=tM.tweenScroll[tw.p],tz.scrubDuration=function(e){(eL=el(e)&&e)?eX?eX.duration(e):eX=n.to(r,{ease:"expo",totalProgress:"+=0",duration:eL,paused:!0,onComplete:function(){return tf&&tf(tz)}}):(eX&&eX.progress(1).kill(),eX=0)},r&&(r.vars.lazy=!1,r._initted&&!tz.isReverted||!1!==r.vars.immediateRender&&!1!==t.immediateRender&&r.duration()&&r.render(0,!0,!0),tz.animation=r.pause(),r.scrollTrigger=tz,tz.scrubDuration(e6),ez=0,e2||(e2=r.vars.id)),tv&&((!ec(tv)||tv.push)&&(tv={snapTo:tv}),"scrollBehavior"in c.style&&n.set(tE?[c,l]:tS,{scrollBehavior:"auto"}),(0,I._scrollers).forEach(function(e){return es(e)&&e.target===(tE?s.scrollingElement||l:tS)&&(e.smooth=!1)}),h=es(tv.snapTo)?tv.snapTo:"labels"===tv.snapTo?(o=r,function(e){return n.utils.snap(ek(o),e)}):"labelsDirectional"===tv.snapTo?(i=r,function(e,t){return eO(ek(i))(e,t.direction)}):!1!==tv.directional?function(e,t){return eO(tv.snapTo)(e,B()-tY<500?0:t.direction)}:n.utils.snap(tv.snapTo),eW=ec(eW=tv.duration||{min:.1,max:2})?d(eW.min,eW.max):d(eW,eW),eU=n.delayedCall(tv.delay||eL/2||.1,function(){var e=tF(),t=B()-tY<500,o=u.tween;if((t||10>Math.abs(tz.getVelocity()))&&!o&&!m&&tD!==e){var i=(e-x)/O,a=r&&!tT?r.totalProgress():i,s=t?0:(a-eN)/(B()-g)*1e3||0,l=n.utils.clamp(-i,1-i,ep(s/2)*s/.185),c=i+(!1===tv.inertia?0:l),f=d(0,1,h(c,tz)),p=Math.round(x+f*O),v=tv,y=v.onStart,b=v.onInterrupt,_=v.onComplete;if(e<=w&&e>=x&&p!==e){if(o&&!o._initted&&o.data<=ep(p-e))return;!1===tv.inertia&&(l=f-i),u(p,{duration:eW(ep(.185*Math.max(ep(c-a),ep(f-a))/s/.05||0)),ease:tv.ease||"power3",data:ep(p-e),// record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
onInterrupt:function(){return eU.restart(!0)&&b&&b(tz)},onComplete:function(){tz.update(),tD=tF(),ez=eN=r&&!tT?r.totalProgress():tz.progress,tg&&tg(tz),_&&_(tz)}},e,l*O,p-e-l*O),y&&y(tz,u.tween)}}else tz.isActive&&tD!==e&&eU.restart(!0)}).pause()),e2&&(eH[e2]=tz),(eJ=(e9=tz.trigger=(0,I._getTarget)(e9||!0!==e7&&e7))&&e9._gsap&&e9._gsap.stRevert)&&(eJ=eJ(tz)),e7=!0===e7?e9:(0,I._getTarget)(e7),ea(e1)&&(e1={targets:e9,className:e1}),e7&&(!1===te||te===ew||(te=(!!te||!e7.parentNode||!e7.parentNode.style||"flex"!==eM(e7.parentNode).display)&&ex),tz.pin=e7,(f=n.core.getCache(e7)).spacer?z=f.pinState:(ty&&((ty=(0,I._getTarget)(ty))&&!ty.nodeType&&(ty=ty.current||ty.nativeElement),f.spacerIsNative=!!ty,ty&&(f.spacerState=ti(ty))),f.spacer=D=ty||s.createElement("div"),D.classList.add("pin-spacer"),e2&&D.classList.add("pin-spacer-"+e2),f.pinState=z=ti(e7)),!1!==t.force3D&&n.set(e7,{force3D:!0}),tz.spacer=D=f.spacer,Q=(eh=eM(e7))[te+tw.os2],H=n.getProperty(e7),j=n.quickSetter(e7,tw.a,"px"),tr(e7,D,eh),R=ti(e7)),tk){C=ec(tk)?eP(tk,eD):eD,P=eI("scroller-start",e2,tS,tw,C,0),A=eI("scroller-end",e2,tS,tw,C,0,P),X=P["offset"+tw.op.d2];var tI=(0,I._getTarget)((0,I._getProxyProp)(tS,"content")||tS);M=this.markerStart=eI("start",e2,tI,tw,C,X,0,tb),E=this.markerEnd=eI("end",e2,tI,tw,C,X,0,tb),tb&&(eK=n.quickSetter([M,E],tw.a,"px")),tP||I._proxies.length&&!0===(0,I._getProxyProp)(tS,"fixedMarkers")||(eE(tE?c:tS),n.set([P,A],{force3D:!0}),ei=n.quickSetter(P,tw.a,"px"),eg=n.quickSetter(A,tw.a,"px"))}if(tb){var tL=tb.vars.onUpdate,tB=tb.vars.onUpdateParams;tb.eventCallback("onUpdate",function(){tz.update(0,0,1),tL&&tL.apply(tb,tB||[])})}if(tz.previous=function(){return eB[eB.indexOf(tz)-1]},tz.next=function(){return eB[eB.indexOf(tz)+1]},tz.revert=function(e,t){if(!t)return tz.kill(!0);// for compatibility with gsap.context() and gsap.matchMedia() which call revert()
var n=!1!==e||!tz.enabled,o=v;n!==tz.isReverted&&(n&&(ej=Math.max(tF(),tz.scroll.rec||0),tX=tz.progress,eZ=r&&r.progress()),M&&[M,E,P,A].forEach(function(e){return e.style.display=n?"none":"block"}),n&&(v=tz,tz.update(n)),!e7||tm&&tz.isActive||(n?tt(e7,D,z):tr(e7,D,eM(e7),et)),n||tz.update(n),v=o,tz.isReverted=n)},tz.refresh=function(o,i,a,f){// position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects
if(!v&&tz.enabled||i){if(e7&&o&&W){eq(e,"scrollEnd",e$);return}!Y&&tq&&tq(tz),v=tz,u.tween&&!a&&(// we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.
u.tween.kill(),u.tween=0),eX&&eX.pause(),tn&&r&&r.revert({kill:!1}).invalidate(),tz.isReverted||tz.revert(!0,!0),tz._subPinOffset=!1;var p,d,g,h,m,b,T,C,N,X,F,L,V,G=tR(),j=tN(),$=tb?tb.duration():eo(tS,tw),K=O<=.01,Q=0,ee=f||0,er=ec(a)?a.end:t.end,en=t.endTrigger||e9,ei=ec(a)?a.start:t.start||(0!==t.start&&e9?e7?"0 0":"0 100%":0),el=tz.pinnedContainer=t.pinnedContainer&&(0,I._getTarget)(t.pinnedContainer,tz),eu=e9&&Math.max(0,eB.indexOf(tz))||0,ef=eu;for(tk&&ec(a)&&(// if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.
L=n.getProperty(P,tw.p),V=n.getProperty(A,tw.p));ef--;)// user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
(b=eB[ef]).end||b.refresh(0,1)||(v=tz),(T=b.pin)&&(T===e9||T===e7||T===el)&&!b.isReverted&&(X||(X=[]),X.unshift(b),b.revert(!0,!0)),b!==eB[ef]&&(// in case it got removed.
eu--,ef--);for(es(ei)&&(ei=ei(tz)),x=tl(ei=U(ei,"start",tz),e9,G,tw,tF(),M,P,tz,j,tO,tP,$,tb,tz._startClamp&&"_startClamp")||(e7?-.001:0),es(er)&&(er=er(tz)),ea(er)&&!er.indexOf("+=")&&(~er.indexOf(" ")?er=(ea(ei)?ei.split(" ")[0]:"")+er:(Q=eF(er.substr(2),G),er=ea(ei)?ei:(tb?n.utils.mapRange(0,tb.duration(),tb.scrollTrigger.start,tb.scrollTrigger.end,x):x)+Q,en=e9)),er=U(er,"end",tz),w=Math.max(x,tl(er||(en?"100% 0":$),en,G,tw,tF()+Q,E,A,tz,j,tO,tP,$,tb,tz._endClamp&&"_endClamp"))||-.001,Q=0,ef=eu;ef--;)(T=(b=eB[ef]).pin)&&b.start-b._pinPush<=x&&!tb&&b.end>0&&(p=b.end-(tz._startClamp?Math.max(0,b.start):b.start),(T===e9&&b.start-b._pinPush<x||T===el)&&isNaN(ei)&&(Q+=p*(1-b.progress)),T===e7&&(ee+=p));if(x+=Q,w+=Q,tz._startClamp&&(tz._startClamp+=Q),tz._endClamp&&!Y&&(tz._endClamp=w||-.001,w=Math.min(w,eo(tS,tw))),O=w-x||(x-=.01)&&.001,K&&(tX=n.utils.clamp(0,1,n.utils.normalize(x,w,ej))),tz._pinPush=ee,M&&Q&&(// offset the markers if necessary
(p={})[tw.a]="+="+Q,el&&(p[tw.p]="-="+tF()),n.set([M,E],p)),e7)p=eM(e7),h=tw===I._vertical,g=tF(),Z=parseFloat(H(tw.a))+ee,!$&&w>1&&(F={style:// makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
F=(tE?s.scrollingElement||l:tS).style,value:F["overflow"+tw.a.toUpperCase()]},tE&&"scroll"!==eM(c)["overflow"+tw.a.toUpperCase()]&&(F.style["overflow"+tw.a.toUpperCase()]="scroll")),tr(e7,D,p),R=ti(e7),d=eA(e7,!0),C=tP&&(0,I._getScrollFunc)(tS,h?I._horizontal:I._vertical)(),te&&((et=[te+tw.os2,O+ee+"px"]).t=D,(ef=te===ex?eC(e7,tw)+O+ee:0)&&et.push(tw.d,ef+"px"),to(et),el&&eB.forEach(function(e){e.pin===el&&!1!==e.vars.pinSpacing&&(e._subPinOffset=!0)}),tP&&tF(ej)),tP&&((m={top:d.top+(h?g-x:C)+"px",left:d.left+(h?C:g-x)+"px",boxSizing:"border-box",position:"fixed"})[ev]=m["max"+eT]=Math.ceil(d.width)+"px",m[em]=m["max"+eS]=Math.ceil(d.height)+"px",m[ew]=m[ew+"Top"]=m[ew+ey]=m[ew+e_]=m[ew+eb]="0",m[ex]=p[ex],m[ex+"Top"]=p[ex+"Top"],m[ex+ey]=p[ex+ey],m[ex+e_]=p[ex+e_],m[ex+eb]=p[ex+eb],q=ta(z,m,tm),Y&&tF(0)),r?(// the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
N=r._initted,S(1),r.render(r.duration(),!0,!0),J=H(tw.a)-Z+O+ee,ed=Math.abs(O-J)>1,tP&&ed&&q.splice(q.length-2,2),r.render(0,!0,!0),N||r.invalidate(!0),r.parent||r.totalTime(r.totalTime()),S(0)):J=O,F&&(F.value?F.style["overflow"+tw.a.toUpperCase()]=F.value:F.style.removeProperty("overflow-"+tw.a));else if(e9&&tF()&&!tb)for(// it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
d=e9.parentNode;d&&d!==c;)d._pinOffset&&(x-=d._pinOffset,w-=d._pinOffset),d=d.parentNode;X&&X.forEach(function(e){return e.revert(!1,!0)}),tz.start=x,tz.end=w,y=_=Y?ej:tF(),tb||Y||(y<ej&&tF(ej),tz.scroll.rec=0),tz.revert(!1,!0),tY=B(),eU&&(tD=-1,// self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.
eU.restart(!0)),v=0,r&&tT&&(r._initted||eZ)&&r.progress()!==eZ&&r.progress(eZ||0,!0).render(r.time(),!0,!0),(K||tX!==tz.progress||tb)&&(// ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
r&&!tT&&r.totalProgress(tb&&x<-.001&&!tX?n.utils.normalize(x,w,0):tX,!0),tz.progress=K||(y-x)/O===tX?0:tX),e7&&te&&(D._pinOffset=Math.round(tz.progress*J)),eX&&eX.invalidate(),isNaN(L)||(// numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like "top", "center", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.
L-=n.getProperty(P,tw.p),V-=n.getProperty(A,tw.p),tp(P,tw,L),tp(M,tw,L-(f||0)),tp(A,tw,V),tp(E,tw,V-(f||0))),K&&!Y&&tz.update(),!e4||Y||k||(// when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.
k=!0,e4(tz),k=!1)}},tz.getVelocity=function(){return(tF()-_)/(B()-g)*1e3||0},tz.endAnimation=function(){eu(tz.callbackAnimation),r&&(eX?eX.progress(1):r.paused()?tT||eu(r,tz.direction<0,1):eu(r,r.reversed()))},tz.labelToScroll=function(e){return r&&r.labels&&(x||tz.refresh()||x)+r.labels[e]/r.duration()*O||0},tz.getTrailing=function(e){var t=eB.indexOf(tz),r=tz.direction>0?eB.slice(0,t).reverse():eB.slice(t+1);return(ea(e)?r.filter(function(t){return t.vars.preventOverlaps===e}):r).filter(function(e){return tz.direction>0?e.end<=x:e.start>=w})},tz.update=function(e,t,n){if(!tb||n||e){var o,i,a,s,l,f,d,h=!0===Y?ej:tz.scroll(),m=e?0:(h-x)/O,b=m<0?0:m>1?1:m||0,T=tz.progress;if(t&&(_=y,y=tb?tF():h,tv&&(eN=ez,ez=r&&!tT?r.totalProgress():b)),tc&&!b&&e7&&!v&&!L&&W&&x<h+(h-_)/(B()-g)*tc&&(b=1e-4),b!==T&&tz.enabled){if(s=(l=(o=tz.isActive=!!b&&b<1)!=(!!T&&T<1))||!!b!=!!T,tz.direction=b>T?1:-1,tz.progress=b,s&&!v&&(i=b&&!T?0:1===b?1:1===T?2:3,tT&&(a=!l&&"none"!==tC[i+1]&&tC[i+1]||tC[i],d=r&&("complete"===a||"reset"===a||a in r))),tx&&(l||d)&&(d||e6||!r)&&(es(tx)?tx(tz):tz.getTrailing(tx).forEach(function(e){return e.endAnimation()})),!tT&&(!eX||v||L?r&&r.totalProgress(b,!!(v&&(tY||e))):(eX._dp._time-eX._start!==eX._time&&eX.render(eX._dp._time-eX._start),eX.resetTo?eX.resetTo("totalProgress",b,r._tTime/r._tDur):(// legacy support (courtesy), before 3.10.0
eX.vars.totalProgress=b,eX.invalidate().restart()))),e7){if(e&&te&&(D.style[te+tw.os2]=Q),tP){if(s){if(f=!e&&b>T&&w+1>h&&h+1>=eo(tS,tw),tm){if(!e&&(o||f)){var S=eA(e7,!0),M=h-x;tu(e7,c,S.top+(tw===I._vertical?M:0)+"px",S.left+(tw===I._vertical?0:M)+"px")}else tu(e7,D)}to(o||f?q:R),ed&&b<1&&o||j(Z+(1!==b||f?0:J))}}else j(K(Z+J*b))}!tv||u.tween||v||L||eU.restart(!0),e1&&(l||th&&b&&(b<1||!N))&&p(e1.targets).forEach(function(e){return e.classList[o||th?"add":"remove"](e1.className)}),!e0||tT||e||e0(tz),s&&!v?(tT&&(d&&("complete"===a?r.pause().totalProgress(1):"reset"===a?r.restart(!0).pause():"restart"===a?r.restart(!0):r[a]()),e0&&e0(tz)),(l||!N)&&(// on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
e3&&l&&ef(tz,e3),tA[i]&&ef(tz,tA[i]),th&&(1===b?tz.kill(!1,1):tA[i]=0),!l&&tA[// it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
i=1===b?1:3]&&ef(tz,tA[i])),t_&&!o&&Math.abs(tz.getVelocity())>(el(t_)?t_:2500)&&(eu(tz.callbackAnimation),eX?eX.progress(1):eu(r,"reverse"===a?1:!b,1))):tT&&e0&&!v&&e0(tz)}// update absolutely-positioned markers (only if the scroller isn't the viewport)
if(eg){var E=tb?h/tb.duration()*(tb._caScrollDist||0):h;ei(E+(P._isFlipped?1:0)),eg(E)}eK&&eK(-h/tb.duration()*(tb._caScrollDist||0))}},tz.enable=function(t,r){tz.enabled||(tz.enabled=!0,eq(tS,"resize",eG),tE||eq(tS,"scroll",eV),tq&&eq(e,"refreshInit",tq),!1!==t&&(tz.progress=tX=0,y=_=tD=tF()),!1!==r&&tz.refresh())},tz.getTween=function(e){return e&&u?u.tween:eX},tz.setPositions=function(e,t,r,n){// doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
if(tb){// convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.
var o=tb.scrollTrigger,i=tb.duration(),a=o.end-o.start;e=o.start+a*e/i,t=o.start+a*t/i}tz.refresh(!1,!1,{start:G(e,r&&!!tz._startClamp),end:G(t,r&&!!tz._endClamp)},n),tz.update()},tz.adjustPinSpacing=function(e){if(et&&e){var t=et.indexOf(tw.d)+1;et[t]=parseFloat(et[t])+e+"px",et[1]=parseFloat(et[1])+e+"px",to(et)}},tz.disable=function(t,r){if(tz.enabled&&(!1!==t&&tz.revert(!0,!0),tz.enabled=tz.isActive=!1,r||eX&&eX.pause(),ej=0,f&&(f.uncache=1),tq&&eR(e,"refreshInit",tq),eU&&(eU.pause(),u.tween&&u.tween.kill()&&(u.tween=0)),!tE)){for(var n=eB.length;n--;)if(eB[n].scroller===tS&&eB[n]!==tz)return;//don't remove the listeners if there are still other triggers referencing it.
eR(tS,"resize",eG),tE||eR(tS,"scroll",eV)}},tz.kill=function(e,n){tz.disable(e,n),eX&&!n&&eX.kill(),e2&&delete eH[e2];var o=eB.indexOf(tz);o>=0&&eB.splice(o,1),o===b&&e8>0&&b--,// if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.
o=0,eB.forEach(function(e){return e.scroller===tz.scroller&&(o=1)}),o||Y||(tz.scroll.rec=0),r&&(r.scrollTrigger=null,e&&r.revert({kill:!1}),n||r.kill()),M&&[M,E,P,A].forEach(function(e){return e.parentNode&&e.parentNode.removeChild(e)}),F===tz&&(F=0),e7&&(f&&(f.uncache=1),o=0,eB.forEach(function(e){return e.pin===e7&&o++}),o||(f.spacer=0)),t.onKill&&t.onKill(tz)},eB.push(tz),tz.enable(!1,!1),eJ&&eJ(tz),r&&r.add&&!O){// if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
var tH=tz.update;// some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().
tz.update=function(){tz.update=tH,x||w||tz.refresh()},n.delayedCall(.01,tz.update),O=.01,x=w=0}else tz.refresh();e7&&e5()},e.register=function(t){return o||(n=t||Q(),J()&&window.document&&e.enable(),o=V),o},e.defaults=function(e){if(e)for(var t in e)eY[t]=e[t];return eY},e.disable=function(e,t){V=0,eB.forEach(function(r){return r[t?"kill":"disable"](e)}),eR(a,"wheel",eV),eR(s,"scroll",eV),clearInterval(h),eR(s,"touchcancel",$),eR(c,"touchstart",$),ez(eR,s,"pointerdown,touchstart,mousedown",j),ez(eR,s,"pointerup,touchend,mouseup",Z),f.kill(),ei(eR);for(var r=0;r<I._scrollers.length;r+=3)eN(eR,I._scrollers[r],I._scrollers[r+1]),eN(eR,I._scrollers[r],I._scrollers[r+2])},e.enable=function(){if(a=window,l=(s=document).documentElement,c=s.body,n&&(p=n.utils.toArray,d=n.utils.clamp,O=n.core.context||$,S=n.core.suppressOverwrites||$,z=a.history.scrollRestoration||"auto",e6=a.pageYOffset,n.core.globals("ScrollTrigger",e),c)){V=1,(q=document.createElement("div")).style.height="100vh",q.style.position="absolute",e3(),function e(){return V&&requestAnimationFrame(e)}(),(0,I.Observer).register(n),e.isTouch=I.Observer.isTouch,k=I.Observer.isTouch&&/(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),eq(a,"wheel",eV),u=[a,s,l,c],n.matchMedia?(e.matchMedia=function(e){var t,r=n.matchMedia();for(t in e)r.add(t,e[t]);return r},n.addEventListener("matchMediaInit",function(){return e0()}),n.addEventListener("matchMediaRevert",function(){return eQ()}),n.addEventListener("matchMedia",function(){e4(0,1),eK("matchMedia")}),n.matchMedia("(orientation: portrait)",function(){return(// when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
eU(),eU)})):console.warn("Requires GSAP 3.11.0 or later"),eU(),eq(s,"scroll",eV);var t,r,i=c.style,g=i.borderTopStyle,v=n.core.Animation.prototype;for(v.revert||Object.defineProperty(v,"revert",{value:function(){return this.time(-.01,!0)}}),i.borderTopStyle="solid",t=eA(c),I._vertical.m=Math.round(t.top+(0,I._vertical).sc())||0,I._horizontal.m=Math.round(t.left+(0,I._horizontal).sc())||0,g?i.borderTopStyle=g:i.removeProperty("border-top-style"),h=setInterval(eW,250),n.delayedCall(.5,function(){return L=0}),eq(s,"touchcancel",$),eq(c,"touchstart",$),ez(eq,s,"pointerdown,touchstart,mousedown",j),ez(eq,s,"pointerup,touchend,mouseup",Z),y=n.utils.checkPrefix("transform"),te.push(y),o=B(),f=n.delayedCall(.2,e4).pause(),w=[s,"visibilitychange",function(){var e=a.innerWidth,t=a.innerHeight;s.hidden?(_=e,x=t):(_!==e||x!==t)&&eG()},s,"DOMContentLoaded",e4,a,"load",e4,a,"resize",eG],ei(eq),eB.forEach(function(e){return e.enable(0,1)}),r=0;r<I._scrollers.length;r+=3)eN(eR,I._scrollers[r],I._scrollers[r+1]),eN(eR,I._scrollers[r],I._scrollers[r+2])}},e.config=function(t){"limitCallbacks"in t&&(N=!!t.limitCallbacks);var r=t.syncInterval;r&&clearInterval(h)||(h=r)&&setInterval(eW,r),"ignoreMobileResize"in t&&(P=1===e.isTouch&&t.ignoreMobileResize),"autoRefreshEvents"in t&&(ei(eR)||ei(eq,t.autoRefreshEvents||"none"),M=-1===(t.autoRefreshEvents+"").indexOf("resize"))},e.scrollerProxy=function(e,t){var r=(0,I._getTarget)(e),n=(0,I._scrollers).indexOf(r),o=ee(r);~n&&(0,I._scrollers).splice(n,o?6:2),t&&(o?(0,I._proxies).unshift(a,t,c,t,l,t):(0,I._proxies).unshift(r,t))},e.clearMatchMedia=function(e){eB.forEach(function(t){return t._ctx&&t._ctx.query===e&&t._ctx.kill(!0,!0)})},e.isInViewport=function(e,t,r){var n=(ea(e)?(0,I._getTarget)(e):e).getBoundingClientRect(),o=n[r?ev:em]*t||0;return r?n.right-o>0&&n.left+o<a.innerWidth:n.bottom-o>0&&n.top+o<a.innerHeight},e.positionInViewport=function(e,t,r){ea(e)&&(e=(0,I._getTarget)(e));var n=e.getBoundingClientRect(),o=n[r?ev:em],i=null==t?o/2:t in eX?eX[t]*o:~t.indexOf("%")?parseFloat(t)*o/100:parseFloat(t)||0;return r?(n.left+i)/a.innerWidth:(n.top+i)/a.innerHeight},e.killAll=function(e){if(eB.slice(0).forEach(function(e){return"ScrollSmoother"!==e.vars.id&&e.kill()}),!0!==e){var t=ej.killAll||[];ej={},t.forEach(function(e){return e()})}},e}();tg.version="3.12.2",tg.saveStyles=function(e){return e?p(e).forEach(function(e){// saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
if(e&&e.style){var t=eJ.indexOf(e);t>=0&&eJ.splice(t,5),eJ.push(e,e.style.cssText,e.getBBox&&e.getAttribute("transform"),n.core.getCache(e),O())}}):eJ},tg.revert=function(e,t){return e0(!e,t)},tg.create=function(e,t){return new tg(e,t)},tg.refresh=function(e){return e?eG():(o||tg.register())&&e4(!0)},tg.update=function(e){return++I._scrollers.cache&&e9(!0===e?2:0)},tg.clearScrollMemory=e1,tg.maxScroll=function(e,t){return eo(e,t?I._horizontal:I._vertical)},tg.getScrollFunc=function(e,t){return(0,I._getScrollFunc)((0,I._getTarget)(e),t?I._horizontal:I._vertical)},tg.getById=function(e){return eH[e]},tg.getAll=function(){return eB.filter(function(e){return"ScrollSmoother"!==e.vars.id})},tg.isScrolling=function(){return!!W},tg.snapDirectional=eO,tg.addEventListener=function(e,t){var r=ej[e]||(ej[e]=[]);~r.indexOf(t)||r.push(t)},tg.removeEventListener=function(e,t){var r=ej[e],n=r&&r.indexOf(t);n>=0&&r.splice(n,1)},tg.batch=function(e,t){var r,o=[],i={},a=t.interval||.016,s=t.batchMax||1e9,l=function(e,t){var r=[],o=[],i=n.delayedCall(a,function(){t(r,o),r=[],o=[]}).pause();return function(e){r.length||i.restart(!0),r.push(e.trigger),o.push(e),s<=r.length&&i.progress(1)}};for(r in t)i[r]="on"===r.substr(0,2)&&es(t[r])&&"onRefreshInit"!==r?l(r,t[r]):t[r];return es(s)&&(s=s(),eq(tg,"refresh",function(){return s=t.batchMax()})),p(e).forEach(function(e){var t={};for(r in i)t[r]=i[r];t.trigger=e,o.push(tg.create(t))}),o};var th,tv=function(e,t,r,n){return t>n?e(n):t<0&&e(0),r>n?(n-t)/(r-t):r<0?t/(t-r):1},tm=function e(t,r){!0===r?t.style.removeProperty("touch-action"):t.style.touchAction=!0===r?"auto":r?"pan-"+r+(I.Observer.isTouch?" pinch-zoom":""):"none",t===l&&e(c,r)},ty={auto:1,scroll:1},tb=function(e){var t,r=e.event,o=e.target,i=e.axis,a=(r.changedTouches?r.changedTouches[0]:r).target,s=a._gsap||n.core.getCache(a),l=B();if(!s._isScrollT||l-s._isScrollT>2e3){// cache for 2 seconds to improve performance.
for(;a&&a!==c&&(a.scrollHeight<=a.clientHeight&&a.scrollWidth<=a.clientWidth||!(ty[(t=eM(a)).overflowY]||ty[t.overflowX]));)a=a.parentNode;s._isScroll=a&&a!==o&&!ee(a)&&(ty[(t=eM(a)).overflowY]||ty[t.overflowX]),s._isScrollT=l}(s._isScroll||"x"===i)&&(r.stopPropagation(),r._gsapAllow=!0)},t_=function(e,t,r,n){return(0,I.Observer).create({target:e,capture:!0,debounce:!1,lockAxis:!0,type:t,onWheel:n=n&&tb,onPress:n,onDrag:n,onScroll:n,onEnable:function(){return r&&eq(s,I.Observer.eventTypes[0],tw,!1,!0)},onDisable:function(){return eR(s,I.Observer.eventTypes[0],tw,!0)}})},tx=/(input|label|select|textarea)/i,tw=function(e){var t=tx.test(e.target.tagName);(t||th)&&(e._gsapAllow=!0,th=t)},tT=function(e){ec(e)||(e={}),e.preventDefault=e.isNormalizer=e.allowClicks=!0,e.type||(e.type="wheel,touch"),e.debounce=!!e.debounce,e.id=e.id||"normalizer";var t,r,o,i,s,c,u,f,p=e,g=p.normalizeScrollX,h=p.momentum,v=p.allowNestedScroll,m=p.onRelease,y=(0,I._getTarget)(e.target)||l,b=n.core.globals().ScrollSmoother,_=b&&b.get(),x=k&&(e.content&&(0,I._getTarget)(e.content)||_&&!1!==e.content&&!_.smooth()&&_.content()),w=(0,I._getScrollFunc)(y,I._vertical),T=(0,I._getScrollFunc)(y,I._horizontal),S=1,M=(I.Observer.isTouch&&a.visualViewport?a.visualViewport.scale*a.visualViewport.width:a.outerWidth)/a.innerWidth,E=0,P=es(h)?function(){return h(t)}:function(){return h||2.8},A=t_(y,e.type,!0,v),C=function(){return i=!1},O=$,z=$,q=function(){r=eo(y,I._vertical),z=d(k?1:0,r),g&&(O=d(0,eo(y,I._horizontal))),o=e2},R=function(){x._gsap.y=K(parseFloat(x._gsap.y)+w.offset)+"px",x.style.transform="matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, "+parseFloat(x._gsap.y)+", 0, 1)",w.offset=w.cacheID=0},N=function(){if(i){requestAnimationFrame(C);var e=K(t.deltaY/2),r=z(w.v-e);if(x&&r!==w.v+w.offset){w.offset=r-w.v;var n=K((parseFloat(x&&x._gsap.y)||0)-w.offset);x.style.transform="matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, "+n+", 0, 1)",x._gsap.y=n+"px",w.cacheID=I._scrollers.cache,e9()}return!0}w.offset&&R(),i=!0},D=function(){// if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
q(),s.isActive()&&s.vars.scrollY>r&&(w()>r?s.progress(1)&&w(r):s.resetTo("scrollY",r))};return x&&n.set(x,{y:"+=0"}),e.ignoreCheck=function(e){return k&&"touchmove"===e.type&&N(e)||S>1.05&&"touchstart"!==e.type||t.isGesturing||e.touches&&e.touches.length>1},e.onPress=function(){i=!1;var e=S;S=K((a.visualViewport&&a.visualViewport.scale||1)/M),s.pause(),e!==S&&tm(y,S>1.01||!g&&"x"),c=T(),u=w(),q(),o=e2},e.onRelease=e.onGestureStart=function(e,t){if(w.offset&&R(),t){I._scrollers.cache++;// alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)
var o,i,a=P();g&&(i=(o=T())+-(.05*a*e.velocityX)/.227,a*=tv(T,o,i,eo(y,I._horizontal)),s.vars.scrollX=O(i)),i=(o=w())+-(.05*a*e.velocityY)/.227,a*=tv(w,o,i,eo(y,I._vertical)),s.vars.scrollY=z(i),s.invalidate().duration(a).play(.01),(k&&s.vars.scrollY>=r||o>=r-1)&&n.to({},{onUpdate:D,duration:a})}else f.restart(!0);m&&m(e)},e.onWheel=function(){s._ts&&s.pause(),B()-E>1e3&&(// after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
o=0,E=B())},e.onChange=function(e,t,r,n,i){if(e2!==o&&q(),t&&g&&T(O(n[2]===t?c+(e.startX-e.x):T()+t-n[1])),r){w.offset&&R();var a=i[2]===r,s=a?u+e.startY-e.y:w()+r-i[1],l=z(s);a&&s!==l&&(u+=l-s),w(l)}(r||t)&&e9()},e.onEnable=function(){tm(y,!g&&"x"),tg.addEventListener("refresh",D),eq(a,"resize",D),w.smooth&&(w.target.style.scrollBehavior="auto",w.smooth=T.smooth=!1),A.enable()},e.onDisable=function(){tm(y,!0),eR(a,"resize",D),tg.removeEventListener("refresh",D),A.kill()},e.lockAxis=!1!==e.lockAxis,(t=new I.Observer(e)).iOS=k,k&&!w()&&w(1),k&&n.ticker.add($),f=t._dc,s=n.to(t,{ease:"power4",paused:!0,scrollX:g?"+=0.1":"+=0",scrollY:"+=0.1",modifiers:{scrollY:tf(w,w(),function(){return s.pause()})},onUpdate:e9,onComplete:f.vars.onComplete}),t};tg.sort=function(e){return eB.sort(e||function(e,t){return -1e6*(e.vars.refreshPriority||0)+e.start-(t.start+-1e6*(t.vars.refreshPriority||0))})},tg.observe=function(e){return new I.Observer(e)},tg.normalizeScroll=function(e){if(void 0===e)return E;if(!0===e&&E)return E.enable();if(!1===e)return E&&E.kill();var t=e instanceof I.Observer?e:tT(e);return E&&E.target===t.target&&E.kill(),ee(t.target)&&(E=t),t},tg.core={// smaller file size way to leverage in ScrollSmoother and Observer
_getVelocityProp:I._getVelocityProp,_inputObserver:t_,_scrollers:I._scrollers,_proxies:I._proxies,bridge:{// when normalizeScroll sets the scroll position (ss = setScroll)
ss:function(){W||eK("scrollStart"),W=B()},// a way to get the _refreshing value in Observer
ref:function(){return v}}},Q()&&n.registerPlugin(tg)}),i.register("2lFfT",function(t,r){function n(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}e(t.exports,"_scrollers",function(){return _}),e(t.exports,"_proxies",function(){return x}),e(t.exports,"_getProxyProp",function(){return M}),e(t.exports,"_horizontal",function(){return q}),e(t.exports,"_vertical",function(){return R}),e(t.exports,"_getTarget",function(){return N}),e(t.exports,"_getScrollFunc",function(){return D}),e(t.exports,"_getVelocityProp",function(){return Y}),e(t.exports,"Observer",function(){return B});/*!
 * Observer 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*//* eslint-disable */var o,i,a,s,l,c,u,f,p,d,g,h,v,m=function(){return o||"undefined"!=typeof window&&(o=window.gsap)&&o.registerPlugin&&o},y=1,b=[],_=[],x=[],w=Date.now,T=function(e,t){return t},S=function(){var e=p.core,t=e.bridge||{},r=e._scrollers,n=e._proxies;r.push.apply(r,_),n.push.apply(n,x),_=r,x=n,T=function(e,r){return t[e](r)}},M=function(e,t){return~x.indexOf(e)&&x[x.indexOf(e)+1][t]},E=function(e){return!!~d.indexOf(e)},P=function(e,t,r,n,o){return e.addEventListener(t,r,{passive:!n,capture:!!o})},A=function(e,t,r,n){return e.removeEventListener(t,r,!!n)},C="scrollLeft",k="scrollTop",O=function(){return g&&g.isPressed||_.cache++},z=function(e,t){var r=function r(n){// since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
if(n||0===n){y&&(a.history.scrollRestoration="manual");var o=g&&g.isPressed;e(n=r.v=Math.round(n)||(g&&g.iOS?1:0)),r.cacheID=_.cache,o&&T("ss",n)}else(t||_.cache!==r.cacheID||T("ref"))&&(r.cacheID=_.cache,r.v=e());return r.v+r.offset};return r.offset=0,e&&r},q={s:C,p:"left",p2:"Left",os:"right",os2:"Right",d:"width",d2:"Width",a:"x",sc:z(function(e){return arguments.length?a.scrollTo(e,R.sc()):a.pageXOffset||s[C]||l[C]||c[C]||0})},R={s:k,p:"top",p2:"Top",os:"bottom",os2:"Bottom",d:"height",d2:"Height",a:"y",op:q,sc:z(function(e){return arguments.length?a.scrollTo(q.sc(),e):a.pageYOffset||s[k]||l[k]||c[k]||0})},N=function(e,t){return(t&&t._ctx&&t._ctx.selector||o.utils.toArray)(e)[0]||("string"==typeof e&&!1!==o.config().nullTargetWarn?console.warn("Element not found:",e):null)},D=function(e,t){var r=t.s,n=t.sc;// we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
E(e)&&(e=s.scrollingElement||l);var i=_.indexOf(e),a=n===R.sc?1:2;~i||(i=_.push(e)-1),_[i+a]||P(e,"scroll",O);var c=_[i+a],u=c||(_[i+a]=z(M(e,r),!0)||(E(e)?n:z(function(t){return arguments.length?e[r]=t:e[r]})));return u.target=e,c||(u.smooth="smooth"===o.getProperty(e,"scrollBehavior")),u},Y=function(e,t,r){var n=e,o=e,i=w(),a=i,s=t||50,l=Math.max(500,3*s),c=function(e,t){var l=w();t||l-i>s?(o=n,n=e,a=i,i=l):r?n+=e:n=o+(e-o)/(l-a)*(i-a)};return{update:c,reset:function(){o=n=r?0:n,a=i=0},getVelocity:function(e){var t=a,s=o,u=w();return(e||0===e)&&e!==n&&c(e),i===a||u-a>l?0:(n+(r?s:-s))/((r?u:i)-t)*1e3}}},X=function(e,t){return t&&!e._gsapAllow&&e.preventDefault(),e.changedTouches?e.changedTouches[0]:e},F=function(e){var t=Math.max.apply(Math,e),r=Math.min.apply(Math,e);return Math.abs(t)>=Math.abs(r)?t:r},I=function(){(p=o.core.globals().ScrollTrigger)&&p.core&&S()},L=function(e){return(o=e||m())&&"undefined"!=typeof document&&document.body&&(a=window,l=(s=document).documentElement,c=s.body,d=[a,s,l,c],o.utils.clamp,v=o.core.context||function(){},f="onpointerenter"in c?"pointer":"mouse",u=B.isTouch=a.matchMedia&&a.matchMedia("(hover: none), (pointer: coarse)").matches?1:"ontouchstart"in a||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0?2:0,h=B.eventTypes=("ontouchstart"in l?"touchstart,touchmove,touchcancel,touchend":"onpointerdown"in l?"pointerdown,pointermove,pointercancel,pointerup":"mousedown,mousemove,mouseup,mouseup").split(","),setTimeout(function(){return y=0},500),I(),i=1),i};q.op=R,_.cache=0;var B=/*#__PURE__*/function(){var e;function t(e){this.init(e)}return t.prototype.init=function(e){i||L(o)||console.warn("Please gsap.registerPlugin(Observer)"),p||I();var t=e.tolerance,r=e.dragMinimum,n=e.type,d=e.target,m=e.lineHeight,y=e.debounce,_=e.preventDefault,x=e.onStop,T=e.onStopDelay,S=e.ignore,M=e.wheelSpeed,C=e.event,k=e.onDragStart,z=e.onDragEnd,B=e.onDrag,H=e.onPress,W=e.onRelease,V=e.onRight,U=e.onLeft,G=e.onUp,j=e.onDown,Z=e.onChangeX,$=e.onChangeY,K=e.onChange,J=e.onToggleX,Q=e.onToggleY,ee=e.onHover,et=e.onHoverEnd,er=e.onMove,en=e.ignoreCheck,eo=e.isNormalizer,ei=e.onGestureStart,ea=e.onGestureEnd,es=e.onWheel,el=e.onEnable,ec=e.onDisable,eu=e.onClick,ef=e.scrollSpeed,ep=e.capture,ed=e.allowClicks,eg=e.lockAxis,eh=e.onLockAxis;this.target=d=N(d)||l,this.vars=e,S&&(S=o.utils.toArray(S)),t=t||1e-9,r=r||0,M=M||1,ef=ef||1,n=n||"wheel,touch,pointer",y=!1!==y,m||(m=parseFloat(a.getComputedStyle(c).lineHeight)||22);var ev,em,ey,eb,e_,ex,ew,eT=this,eS=0,eM=0,eE=D(d,q),eP=D(d,R),eA=eE(),eC=eP(),ek=~n.indexOf("touch")&&!~n.indexOf("pointer")&&"pointerdown"===h[0],eO=E(d),ez=d.ownerDocument||s,eq=[0,0,0],eR=[0,0,0],eN=0,eD=function(){return eN=w()},eY=function(e,t){return(eT.event=e)&&S&&~S.indexOf(e.target)||t&&ek&&"touch"!==e.pointerType||en&&en(e,t)},eX=function(){var e=eT.deltaX=F(eq),r=eT.deltaY=F(eR),n=Math.abs(e)>=t,o=Math.abs(r)>=t;K&&(n||o)&&K(eT,e,r,eq,eR),n&&(V&&eT.deltaX>0&&V(eT),U&&eT.deltaX<0&&U(eT),Z&&Z(eT),J&&eT.deltaX<0!=eS<0&&J(eT),eS=eT.deltaX,eq[0]=eq[1]=eq[2]=0),o&&(j&&eT.deltaY>0&&j(eT),G&&eT.deltaY<0&&G(eT),$&&$(eT),Q&&eT.deltaY<0!=eM<0&&Q(eT),eM=eT.deltaY,eR[0]=eR[1]=eR[2]=0),(eb||ey)&&(er&&er(eT),ey&&(B(eT),ey=!1),eb=!1),ex&&(ex=!1,1)&&eh&&eh(eT),e_&&(es(eT),e_=!1),ev=0},eF=function(e,t,r){eq[r]+=e,eR[r]+=t,eT._vx.update(e),eT._vy.update(t),y?ev||(ev=requestAnimationFrame(eX)):eX()},eI=function(e,t){eg&&!ew&&(eT.axis=ew=Math.abs(e)>Math.abs(t)?"x":"y",ex=!0),"y"!==ew&&(eq[2]+=e,eT._vx.update(e,!0)),"x"!==ew&&(eR[2]+=t,eT._vy.update(t,!0)),y?ev||(ev=requestAnimationFrame(eX)):eX()},eL=function(e){if(!eY(e,1)){var t=(e=X(e,_)).clientX,n=e.clientY,o=t-eT.x,i=n-eT.y,a=eT.isDragging;eT.x=t,eT.y=n,(a||Math.abs(eT.startX-t)>=r||Math.abs(eT.startY-n)>=r)&&(B&&(ey=!0),a||(eT.isDragging=!0),eI(o,i),a||k&&k(eT))}},eB=eT.onPress=function(e){eY(e,1)||e&&e.button||(eT.axis=ew=null,em.pause(),eT.isPressed=!0,e=X(e),eS=eM=0,eT.startX=eT.x=e.clientX,eT.startY=eT.y=e.clientY,eT._vx.reset(),eT._vy.reset(),P(eo?d:ez,h[1],eL,_,!0),eT.deltaX=eT.deltaY=0,H&&H(eT))},eH=eT.onRelease=function(e){if(!eY(e,1)){A(eo?d:ez,h[1],eL,!0);var t=!isNaN(eT.y-eT.startY),r=eT.isDragging&&(Math.abs(eT.x-eT.startX)>3||Math.abs(eT.y-eT.startY)>3),n=X(e);!r&&t&&(eT._vx.reset(),eT._vy.reset(),_&&ed&&o.delayedCall(.08,function(){// some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
if(w()-eN>300&&!e.defaultPrevented){if(e.target.click)e.target.click();else if(ez.createEvent){var t=ez.createEvent("MouseEvents");t.initMouseEvent("click",!0,!0,a,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),e.target.dispatchEvent(t)}}})),eT.isDragging=eT.isGesturing=eT.isPressed=!1,x&&!eo&&em.restart(!0),z&&r&&z(eT),W&&W(eT,r)}},eW=function(e){return e.touches&&e.touches.length>1&&(eT.isGesturing=!0)&&ei(e,eT.isDragging)},eV=function(){return eT.isGesturing=!1,ea(eT)},eU=function(e){if(!eY(e)){var t=eE(),r=eP();eF((t-eA)*ef,(r-eC)*ef,1),eA=t,eC=r,x&&em.restart(!0)}},eG=function(e){if(!eY(e)){e=X(e,_),es&&(e_=!0);var t=(1===e.deltaMode?m:2===e.deltaMode?a.innerHeight:1)*M;eF(e.deltaX*t,e.deltaY*t,0),x&&!eo&&em.restart(!0)}},ej=function(e){if(!eY(e)){var t=e.clientX,r=e.clientY,n=t-eT.x,o=r-eT.y;eT.x=t,eT.y=r,eb=!0,(n||o)&&eI(n,o)}},eZ=function(e){eT.event=e,ee(eT)},e$=function(e){eT.event=e,et(eT)},eK=function(e){return eY(e)||X(e,_)&&eu(eT)};em=eT._dc=o.delayedCall(T||.25,function(){eT._vx.reset(),eT._vy.reset(),em.pause(),x&&x(eT)}).pause(),eT.deltaX=eT.deltaY=0,eT._vx=Y(0,50,!0),eT._vy=Y(0,50,!0),eT.scrollX=eE,eT.scrollY=eP,eT.isDragging=eT.isGesturing=eT.isPressed=!1,v(this),eT.enable=function(e){return!eT.isEnabled&&(P(eO?ez:d,"scroll",O),n.indexOf("scroll")>=0&&P(eO?ez:d,"scroll",eU,_,ep),n.indexOf("wheel")>=0&&P(d,"wheel",eG,_,ep),(n.indexOf("touch")>=0&&u||n.indexOf("pointer")>=0)&&(P(d,h[0],eB,_,ep),P(ez,h[2],eH),P(ez,h[3],eH),ed&&P(d,"click",eD,!1,!0),eu&&P(d,"click",eK),ei&&P(ez,"gesturestart",eW),ea&&P(ez,"gestureend",eV),ee&&P(d,f+"enter",eZ),et&&P(d,f+"leave",e$),er&&P(d,f+"move",ej)),eT.isEnabled=!0,e&&e.type&&eB(e),el&&el(eT)),eT},eT.disable=function(){eT.isEnabled&&(// only remove the _onScroll listener if there aren't any others that rely on the functionality.
b.filter(function(e){return e!==eT&&E(e.target)}).length||A(eO?ez:d,"scroll",O),eT.isPressed&&(eT._vx.reset(),eT._vy.reset(),A(eo?d:ez,h[1],eL,!0)),A(eO?ez:d,"scroll",eU,ep),A(d,"wheel",eG,ep),A(d,h[0],eB,ep),A(ez,h[2],eH),A(ez,h[3],eH),A(d,"click",eD,!0),A(d,"click",eK),A(ez,"gesturestart",eW),A(ez,"gestureend",eV),A(d,f+"enter",eZ),A(d,f+"leave",e$),A(d,f+"move",ej),eT.isEnabled=eT.isPressed=eT.isDragging=!1,ec&&ec(eT))},eT.kill=eT.revert=function(){eT.disable();var e=b.indexOf(eT);e>=0&&b.splice(e,1),g===eT&&(g=0)},b.push(eT),eo&&E(d)&&(g=eT),eT.enable(C)},n(t.prototype,[{key:"velocityX",get:function(){return this._vx.getVelocity()}},{key:"velocityY",get:function(){return this._vy.getVelocity()}}]),e&&n(t,e),t}();B.version="3.12.2",B.create=function(e){return new B(e)},B.register=L,B.getAll=function(){return b.slice()},B.getById=function(e){return b.filter(function(t){return t.vars.id===e})[0]},m()&&o.registerPlugin(B)});var a=i("1oYLf"),s=i("aV8T4"),l={};l=function(){var e=document,t=e.createTextNode.bind(e);/**
 * # setProperty
 * Apply a CSS var
 * @param el{HTMLElement} 
 * @param varName {string} 
 * @param value {string|number}  
 */function r(e,t,r){e.style.setProperty(t,r)}/**
 * 
 * @param {Node} el 
 * @param {Node} child 
 */function n(e,t){return e.appendChild(t)}function o(t,r,o,i){var a=e.createElement("span");return r&&(a.className=r),o&&(i||a.setAttribute("data-"+r,o),a.textContent=o),t&&n(t,a)||a}function i(e,t){return e.getAttribute("data-"+t)}/**
 * 
 * @param e {import('../types').Target} 
 * @param parent {HTMLElement}
 * @returns {HTMLElement[]}
 */function a(t,r){return t&&0!=t.length?t.nodeName?[t]:[].slice.call(t[0].nodeName?t:(r||e).querySelectorAll(t)):[]}/**
 * Creates and fills an array with the value provided
 * @template {T}
 * @param {number} len
 * @param {() => T} valueProvider
 * @return {T}
 */function s(e){for(var t=[];e--;)t[e]=[];return t}function l(e,t){e&&e.some(t)}function c(e){return function(t){return e[t]}}/**
 * @type {Record<string, import('./types').ISplittingPlugin>}
 */var u={};/**
 * Internal utility for creating plugins... essentially to reduce
 * the size of the library
 * @param {string} by 
 * @param {string} key 
 * @param {string[]} depends 
 * @param {Function} split 
 * @returns {import('./types').ISplittingPlugin}
 */function f(e,t,r,n){return{by:e,depends:t,key:r,split:n}}/**
 * Adds a new plugin to splitting
 * @param opts {import('./types').ISplittingPlugin}
 */function p(e){u[e.by]=e}/**
 * # Splitting.split
 * Split an element's textContent into individual elements
 * @param el {Node} Element to split
 * @param key {string}
 * @param splitOn {string}
 * @param includeSpace {boolean}
 * @returns {HTMLElement[]}
 */function d(e,r,i,s,c){// Combine any strange text nodes or empty whitespace.
e.normalize();// Use fragment to prevent unnecessary DOM thrashing.
var u=[],f=document.createDocumentFragment();s&&u.push(e.previousSibling);var p=[];return a(e.childNodes).some(function(e){if(e.tagName&&!e.hasChildNodes()){// keep elements without child nodes (no text and no children)
p.push(e);return}// Recursively run through child nodes
if(e.childNodes&&e.childNodes.length){p.push(e),u.push.apply(u,d(e,r,i,s,c));return}// Get the text to split, trimming out the whitespace
/** @type {string} */var n=e.wholeText||"",a=n.trim();// If there's no text left after trimming whitespace, continue the loop
a.length&&(" "===n[0]&&p.push(t(" ")),// Concatenate the split text children back into the full array
l(a.split(i),function(e,t){t&&c&&p.push(o(f,"whitespace"," ",c));var n=o(f,r,e);u.push(n),p.push(n)})," "===n[n.length-1]&&p.push(t(" ")))}),l(p,function(e){n(f,e)}),// Clear out the existing element
e.innerHTML="",n(e,f),u}var g="words",h=f(/*by: */g,0,/*key: */"word",/*split: */function(e){return d(e,"word",/\s+/,0,1)}),v="chars",m=f(/*by: */v,/*depends: */[g],/*key: */"char",/*split: */function(e,t,r){var n=[];return l(r[g],function(e,r){n.push.apply(n,d(e,"char","",t.whitespace&&r))}),n});/**
 * # Splitting
 * 
 * @param opts {import('./types').ISplittingOptions} 
 */function y(e){var t=(e=e||{}).key;return a(e.target||"[data-splitting]").map(function(n){var o=n["\uD83C\uDF4C"];if(!e.force&&o)return o;o=n["\uD83C\uDF4C"]={el:n};var a=/**
 * @param by {string}
 * @param parent {string}
 * @param deps {string[]}
 * @return {string[]}
 */(function e(t,r,n){// skip if already visited this dependency
var o=n.indexOf(t);if(-1==o)// if new to dependency array, add to the beginning
n.unshift(t),// recursively call this function for all dependencies
l(u[t].depends,function(r){e(r,t,n)});else{// if this dependency was added already move to the left of
// the parent dependency so it gets loaded in order
var i=n.indexOf(r);n.splice(o,1),n.splice(i,0,t)}return n})(e.by||i(n,"splitting")||v,0,[]).map(c(u)),s=function(e,t){for(var r in t)e[r]=t[r];return e}({},e);return l(a,function(e){if(e.split){var i,a,c=e.by,u=(t?"-"+t:"")+e.key,f=e.split(n,s,o);u&&(a=(i="--"+u)+"-index",l(f,function(e,t){Array.isArray(e)?l(e,function(e){r(e,a,t)}):r(e,a,t)}),r(n,i+"-total",f.length)),o[c]=f,n.classList.add(c)}}),n.classList.add("splitting"),o})}function b(e,t,r){var n=a(t.matching||e.children,e),o={};return l(n,function(e){var t=Math.round(e[r]);(o[t]||(o[t]=[])).push(e)}),Object.keys(o).map(Number).sort(_).map(c(o))}function _(e,t){return e-t}y.html=/**
 * # Splitting.html
 * 
 * @param opts {import('./types').ISplittingOptions}
 */function(e){var t=(e=e||{}).target=o();return t.innerHTML=e.content,y(e),t.outerHTML},y.add=p;var x=f(/*by: */"lines",/*depends: */[g],/*key: */"line",/*split: */function(e,t,r){return b(e,{matching:r[g]},"offsetTop")}),w=f(/*by: */"items",0,/*key: */"item",/*split: */function(e,t){return a(t.matching||e.children,e)}),T=f(/*by: */"rows",0,/*key: */"row",/*split: */function(e,t){return b(e,t,"offsetTop")}),S=f(/*by: */"cols",0,/*key: */"col",/*split: */function(e,t){return b(e,t,"offsetLeft")}),M=f(/*by: */"grid",/*depends: */["rows","cols"]),E="layout",P=f(/*by: */E,0,0,/*split: */function(e,t){// detect and set options
var s=t.rows=+(t.rows||i(e,"rows")||1),l=t.columns=+(t.columns||i(e,"columns")||1);if(// Seek out the first <img> if the value is true 
t.image=t.image||i(e,"image")||e.currentSrc||e.src,t.image){var c=a("img",e)[0];t.image=c&&(c.currentSrc||c.src)}t.image&&r(e,"background-image","url("+t.image+")");for(var u=s*l,f=[],p=o(0,"cell-grid");u--;){// Create a span
var d=o(p,"cell");o(d,"cell-inner"),f.push(d)}return(// Append elements back into the parent
n(e,p),f)}),A=f(/*by: */"cellRows",/*depends: */[E],/*key: */"row",/*split: */function(e,t,r){var n=t.rows,o=s(n);return l(r[E],function(e,t,r){o[Math.floor(t/(r.length/n))].push(e)}),o}),C=f(/*by: */"cellColumns",/*depends: */[E],/*key: */"col",/*split: */function(e,t,r){var n=t.columns,o=s(n);return l(r[E],function(e,t){o[t%n].push(e)}),o}),k=f(/*by: */"cells",/*depends: */["cellRows","cellColumns"],/*key: */"cell",/*split: */function(e,t,r){// re-index the layout as the cells
return r[E]});return(// install plugins
// word/char plugins
p(h),p(m),p(x),// grid plugins
p(w),p(T),p(S),p(M),// cell-layout plugins
p(P),p(A),p(C),p(k),y)}(),(0,a.gsap).registerPlugin(s.ScrollTrigger),((t=l)&&t.__esModule?t.default:t)();const c=[...document.querySelectorAll(".content__title[data-splitting][data-effect16]")],u=[...document.querySelectorAll(".content__title[data-splitting][data-effect17]")],f=[...document.querySelectorAll(".content__title[data-splitting][data-effect18]")],p=[...document.querySelectorAll(".content__title[data-splitting][data-effect19]")],d=[...document.querySelectorAll(".content__title[data-splitting][data-effect20]")],g=[...document.querySelectorAll(".content__title[data-splitting][data-effect21]")],h=[...document.querySelectorAll(".content__title[data-splitting][data-effect22]")],v=[...document.querySelectorAll(".content__title[data-splitting][data-effect23]")],m=[...document.querySelectorAll(".content__title[data-splitting][data-effect24]")],y=[...document.querySelectorAll(".content__title[data-splitting][data-effect25]")],b=[...document.querySelectorAll(".content__title[data-splitting][data-effect26]")],_=[...document.querySelectorAll(".content__title[data-splitting][data-effect27]")],x=[...document.querySelectorAll(".content__title[data-splitting][data-effect28]")],w=[...document.querySelectorAll(".content__title[data-splitting][data-effect29]")],T=()=>{c.forEach(e=>{(0,a.gsap).fromTo(e,{transformOrigin:"0% 50%",rotate:3},{ease:"none",rotate:0,scrollTrigger:{trigger:e,start:"top bottom",end:"top top",scrub:!0}}),(0,a.gsap).fromTo(e.querySelectorAll(".word"),{"will-change":"opacity",opacity:.1},{ease:"none",opacity:1,stagger:.05,scrollTrigger:{trigger:e,start:"top bottom-=20%",end:"center top+=20%",scrub:!0}})}),u.forEach(e=>{let t=e.querySelectorAll(".char");t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:1e3})),(0,a.gsap).fromTo(t,{"will-change":"opacity, transform",opacity:0,rotateX:()=>(0,a.gsap).utils.random(-120,120),z:()=>(0,a.gsap).utils.random(-200,200)},{ease:"none",opacity:1,rotateX:0,z:0,stagger:.02,scrollTrigger:{trigger:e,start:"top bottom",end:"bottom top",scrub:!0}})}),f.forEach(e=>{let t=e.querySelectorAll(".char");t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:1e3})),(0,a.gsap).fromTo(t,{"will-change":"opacity, transform",opacity:.2,z:-800},{ease:"back.out(1.2)",opacity:1,z:0,stagger:.04,scrollTrigger:{trigger:e,start:"top bottom",end:"bottom top",scrub:!0}})}),p.forEach(e=>{let t=e.querySelectorAll(".char");t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:1e3})),(0,a.gsap).fromTo(t,{"will-change":"opacity, transform",transformOrigin:"50% 0%",opacity:0,rotationX:-90,z:-200},{ease:"power1",opacity:1,stagger:.05,rotationX:0,z:0,scrollTrigger:{trigger:e,start:"center bottom",end:"bottom top+=20%",scrub:!0}})}),d.forEach(e=>{let t=e.querySelectorAll(".char");t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:1e3})),(0,a.gsap).fromTo(t,{"will-change":"opacity, transform",transformOrigin:"50% 100%",opacity:0,rotationX:90},{ease:"power4",opacity:1,stagger:{each:.03,from:"random"},rotationX:0,scrollTrigger:{trigger:e,start:"center bottom",end:"bottom top+=20%",scrub:!0}})}),g.forEach(e=>{let t=[...e.querySelectorAll(".word")];for(let e of t){let t=e.querySelectorAll(".char");t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:2e3})),(0,a.gsap).fromTo(t,{"will-change":"opacity, transform",opacity:0,y:(e,t,r)=>-40*Math.abs(e-r.length/2),z:()=>(0,a.gsap).utils.random(-1500,-600),rotationX:()=>(0,a.gsap).utils.random(-500,-200)},{ease:"power1.inOut",opacity:1,y:0,z:0,rotationX:0,stagger:{each:.06,from:"center"},scrollTrigger:{trigger:e,start:"top bottom",end:"top top+=15%",scrub:!0}})}}),h.forEach(e=>{let t=[...e.querySelectorAll(".word")];for(let e of t){let t=e.querySelectorAll(".char"),r=t.length;t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:1e3})),(0,a.gsap).fromTo(t,{"will-change":"transform",x:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return(r%2?Math.abs(Math.ceil(r/2)-1-t):Math.abs(Math.ceil(r/2)-t))*200*(e<r/2?-1:1)},y:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return 60*t},rotationY:-270,rotationZ:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return e<r/2?8*Math.abs(t-r/2):-1*Math.abs(t-r/2)*8}},{ease:"power2.inOut",x:0,y:0,rotationZ:0,rotationY:0,scale:1,scrollTrigger:{trigger:e,start:"top bottom+=40%",end:"top top+=15%",scrub:!0}})}}),v.forEach(e=>{let t=[...e.querySelectorAll(".word")];for(let[e,r]of t.entries())(0,a.gsap).fromTo(r.querySelectorAll(".char"),{"will-change":"transform",scale:.01,x:(t,r,n)=>e%2?50*t:-((n.length-t-1)*50)},{ease:"power4",scale:1,x:0,scrollTrigger:{trigger:r,start:"center bottom",end:"bottom top-=40%",scrub:!0}})}),m.forEach(e=>{let t=e.querySelectorAll(".char"),r=t.length;(0,a.gsap).fromTo(t,{"will-change":"transform",y:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return(r/2-t+6)*130}},{ease:"elastic.out(.4)",y:0,stagger:{amount:.1,from:"center"},scrollTrigger:{trigger:e,start:"top bottom",end:"bottom top-=50%",scrub:!0}})}),y.forEach(e=>{(0,a.gsap).fromTo(e.querySelectorAll(".char"),{"will-change":"transform",transformOrigin:"50% 100%",scaleY:0},{ease:"power3.in",opacity:1,scaleY:1,stagger:.05,scrollTrigger:{trigger:e,start:"center center",end:"+=500%",scrub:!0,pin:e.parentNode}})}),b.forEach(e=>{let t=[...e.querySelectorAll(".word")],r=(0,a.gsap).timeline({scrollTrigger:{trigger:e,start:"center center",end:"+=100%",scrub:!0,pin:e.parentNode}});for(let[e,n]of t.entries())r.fromTo(n.querySelectorAll(".char"),{"will-change":"transform",transformOrigin:()=>!e%2?"50% 0%":"50% 100%",scaleY:0},{ease:"power1.inOut",scaleY:1,stagger:{amount:.3,from:"center"}},0)}),_.forEach(e=>{let t=[...e.querySelectorAll(".word")];t.forEach(e=>(0,a.gsap).set(e.parentNode,{perspective:1e3})),(0,a.gsap).fromTo(t,{"will-change":"opacity, transform",z:()=>(0,a.gsap).utils.random(500,950),opacity:0,xPercent:e=>(0,a.gsap).utils.random(-100,100),yPercent:e=>(0,a.gsap).utils.random(-10,10),rotationX:()=>(0,a.gsap).utils.random(-90,90)},{ease:"expo",opacity:1,rotationX:0,rotationY:0,xPercent:0,yPercent:0,z:0,scrollTrigger:{trigger:e,start:"center center",end:"+=300%",scrub:!0,pin:e.parentNode},stagger:{each:.006,from:"random"}})}),x.forEach(e=>{let t=[...e.querySelectorAll(".word")];for(let e of t){let t=e.querySelectorAll(".char"),r=t.length;(0,a.gsap).fromTo(t,{"will-change":"transform, filter",transformOrigin:"50% 100%",scale:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return(0,a.gsap).utils.mapRange(0,Math.ceil(r/2),.5,2.1,t)},y:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return(0,a.gsap).utils.mapRange(0,Math.ceil(r/2),0,60,t)},rotation:e=>{let t=e<Math.ceil(r/2)?e:Math.ceil(r/2)-Math.abs(Math.floor(r/2)-e)-1;return e<r/2?(0,a.gsap).utils.mapRange(0,Math.ceil(r/2),-4,0,t):(0,a.gsap).utils.mapRange(0,Math.ceil(r/2),0,4,t)},filter:"blur(12px) opacity(0)"},{ease:"power2.inOut",y:0,rotation:0,scale:1,filter:"blur(0px) opacity(1)",scrollTrigger:{trigger:e,start:"top bottom+=40%",end:"top top+=15%",scrub:!0},stagger:{amount:.15,from:"center"}})}}),w.forEach(e=>{let t=[...e.querySelectorAll(".word")];for(let[e,r]of t.entries()){let t=r.querySelectorAll(".char");(0,a.gsap).fromTo(t,{"will-change":"transform",transformOrigin:`${e%2?0:100}% ${e%2?100:0}%`,scale:0},{ease:"power4",scale:1,stagger:{each:.03,from:e%2?"end":"start"},scrollTrigger:{trigger:r,start:"top bottom-=10%",end:"top top",scrub:!0}})}})};new Promise(e=>{WebFont.load({typekit:{id:"cvn8slu"},active:e})}).then(()=>{// Remove loader (loading class)
document.body.classList.remove("loading"),// Lenis (smooth scrolling)
//initSmoothScrolling();
// GSAP Scroll Triggers
T()});